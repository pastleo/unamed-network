// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../ws
//   ../../utility-types

declare module 'unnamed-network' {
    import Agent from 'unnamed-network/agent';
    import BrowserConnManager from 'unnamed-network/conn-manager/browser';
    import WssConnManager from 'unnamed-network/conn-manager/wss';
    export { Agent, BrowserConnManager, WssConnManager };
}

declare module 'unnamed-network/agent' {
    import EventTarget from 'unnamed-network/misc/event-target';
    import ConnManager, { NewConnEvent } from 'unnamed-network/conn-manager/base';
    import { ConnCloseEvent } from 'unnamed-network/conn/base';
    import { Message, MessageData } from 'unnamed-network/message/message';
    import { MessageReceivedEvent } from 'unnamed-network/conn/base';
    import { NetworkMessageReceivedEvent } from 'unnamed-network/misc/events';
    import Identity from 'unnamed-network/misc/identity';
    import TunnelManager from 'unnamed-network/tunnel';
    import RequestManager from 'unnamed-network/request';
    namespace Agent {
        type Config = {
            routeTtl: number;
            requestTimeout: number;
        } & Identity.Config;
    }
    interface EventMap {
        'receive-network': NetworkMessageReceivedEvent;
        'new-conn': NewConnEvent;
        'close': ConnCloseEvent;
    }
    class Agent extends EventTarget<EventMap> {
        myIdentity: Identity;
        connManager: ConnManager;
        tunnelManager: TunnelManager;
        requestManager: RequestManager;
        constructor(connManager: ConnManager, config?: Partial<Agent.Config>);
        start(): Promise<void>;
        connect(peerPath: string, spacePath?: string): Promise<boolean>;
        join(spacePath?: string): Promise<boolean>;
        leave(_spacePath: string): void;
        listKnownAddrs(_spacePath: string): void;
        broadcast(_spacePath: string): void;
        send(path: string, message: MessageData, srcSpacePath?: string): Promise<boolean>;
        protected onReceiveMessage(event: MessageReceivedEvent): Promise<void>;
        route(message: Message, receiveEvent?: MessageReceivedEvent): Promise<boolean>;
    }
    export default Agent;
}

declare module 'unnamed-network/conn-manager/browser' {
    import Agent from 'unnamed-network/agent';
    import ConnManager from 'unnamed-network/conn-manager/base';
    class BrowserConnManager extends ConnManager {
        start(agent: Agent): Promise<void>;
        protected connectWs(peerPath: string, opts: ConnManager.ConnectOptsImpl): Promise<void>;
        protected connectUnnamed(peerPath: string, opts: ConnManager.ConnectOptsImpl): Promise<void>;
    }
    export default BrowserConnManager;
}

declare module 'unnamed-network/conn-manager/wss' {
    import Agent from 'unnamed-network/agent';
    import ConnManager from 'unnamed-network/conn-manager/base';
    import { ServerOptions as WsServerOptions } from 'ws';
    namespace WssConnManager {
        type ServerOptions = WsServerOptions;
    }
    class WssConnManager extends ConnManager {
        constructor(config?: Partial<ConnManager.Config>, opts?: WssConnManager.ServerOptions);
        start(agent: Agent): Promise<void>;
        protected connectWs(peerPath: string, _opts: ConnManager.ConnectOptsImpl): Promise<void>;
        protected connectUnnamed(peerPath: string, _opts: ConnManager.ConnectOptsImpl): Promise<void>;
    }
    export default WssConnManager;
}

declare module 'unnamed-network/misc/event-target' {
    export abstract class CustomEvent<DetailT> {
        abstract readonly type: string;
        readonly detail: DetailT;
        defaultPrevented: boolean;
        constructor(detail: DetailT);
        preventDefault(): void;
    }
    type EventTargetListeners<EventMapT> = {
        [index: string]: ((this: EventTarget<EventMapT>, ev: EventMapT[keyof EventMapT]) => any)[];
    };
    export default class EventTarget<EventMapT> {
        listeners: EventTargetListeners<EventMapT>;
        addEventListener<K extends keyof EventMapT>(type: K & string, listener: (this: EventTarget<EventMapT>, ev: EventMapT[K]) => void): void;
        removeEventListener<K extends keyof EventMapT>(type: K & string, listener: (this: EventTarget<EventMapT>, ev: EventMapT[K]) => void): void;
        dispatchEvent(event: EventMapT[keyof EventMapT] & CustomEvent<any>): boolean;
    }
    export {};
}

declare module 'unnamed-network/conn-manager/base' {
    import Agent from 'unnamed-network/agent';
    import Conn, { MessageReceivedEvent, ConnCloseEvent } from 'unnamed-network/conn/base';
    import EventTarget, { CustomEvent } from 'unnamed-network/misc/event-target';
    import { PeerIdentity } from 'unnamed-network/misc/identity';
    import { Message } from 'unnamed-network/message/message';
    import { Required } from 'utility-types';
    interface RequestToConnEventDetail {
        peerPath: string;
        peerIdentity: PeerIdentity;
    }
    export class RequestToConnEvent extends CustomEvent<RequestToConnEventDetail> {
        type: string;
        peerAddr: string;
        constructor(detail: RequestToConnEventDetail);
        reject(): void;
    }
    interface NewConnEventDetail {
        conn: Conn;
        peerPath: string;
        reconnected: boolean;
    }
    export class NewConnEvent extends CustomEvent<NewConnEventDetail> {
        type: string;
    }
    interface EventMap {
        'request-to-conn': RequestToConnEvent;
        'new-conn': NewConnEvent;
        'close': ConnCloseEvent;
        'receive': MessageReceivedEvent;
    }
    namespace ConnManager {
        interface Config {
            newConnTimeout: number;
            requestToConnTimeout: number;
        }
        interface ConnectOpts {
            peerIdentity?: PeerIdentity;
            timeout?: number;
            beingConnected?: boolean;
            [opt: string]: any;
        }
        type ConnectOptsImpl = Required<ConnectOpts, 'timeout'>;
    }
    abstract class ConnManager extends EventTarget<EventMap> {
        protected conns: Record<string, Conn>;
        protected config: ConnManager.Config;
        constructor(config?: Partial<ConnManager.Config>);
        abstract start(agent: Agent): Promise<void>;
        connect(peerPath: string, opts: ConnManager.ConnectOpts): Promise<void>;
        protected abstract connectWs(peerPath: string, opts: ConnManager.ConnectOptsImpl): Promise<void>;
        protected abstract connectUnnamed(peerPath: string, opts: ConnManager.ConnectOptsImpl): Promise<void>;
        connCount(): number;
        hasConn(peerAddr: string): boolean;
        send(peerAddr: string, message: Message): boolean;
        protected addConn(peerAddr: string, conn: Conn, peerPath: string): void;
    }
    export default ConnManager;
}

declare module 'unnamed-network/conn/base' {
    import EventTarget, { CustomEvent } from 'unnamed-network/misc/event-target';
    import Identity, { PeerIdentity } from 'unnamed-network/misc/identity';
    import { Message } from 'unnamed-network/message/message';
    export class MessageReceivedEvent extends CustomEvent<Message> {
        type: string;
        fromConn: Conn;
        srcAddr: string;
        desAddr: string;
        constructor(fromConn: Conn, detail: Message);
    }
    interface CloseEventDetail {
        conn: Conn;
        bySelf: boolean;
        wsEvent?: CloseEvent;
    }
    export class ConnCloseEvent extends CustomEvent<CloseEventDetail> {
        type: string;
    }
    interface ConnEventMap {
        'receive': MessageReceivedEvent;
        'close': ConnCloseEvent;
    }
    namespace Conn {
        interface StartLinkOpts {
            myIdentity: Identity;
            peerIdentity?: PeerIdentity;
            peerPath: string;
            timeout: number;
            beingConnected?: boolean;
        }
        const enum State {
            NOT_CONNECTED = "NOT_CONNECTED",
            CONNECTED = "CONNECTED",
            FAILED = "FAILED",
            CLOSED = "CLOSED"
        }
    }
    abstract class Conn extends EventTarget<ConnEventMap> {
        connId: string;
        peerIdentity: PeerIdentity;
        state: Conn.State;
        constructor(connId?: string);
        abstract startLink(opts: Conn.StartLinkOpts | {
            [_: string]: any;
        }): Promise<void>;
        abstract close(): Promise<void>;
        abstract send(message: Message): void;
        protected onMessageData(data: string): void;
        protected onClose(detail: CloseEventDetail): void;
    }
    export default Conn;
}

declare module 'unnamed-network/message/message' {
    export interface Message {
        term: string;
        srcPath: string;
        desPath: string;
    }
    export type MessageData = Omit<Message, 'srcPath' | 'desPath'> & {
        [_: string]: any;
    };
    type MessageAddrs = Pick<Message, 'srcPath' | 'desPath'>;
    export type AnyMessage = Message & {
        [_: string]: any;
    };
    export function toMessage(data: any): Message;
    export function messageAddrs(data: AnyMessage): MessageAddrs;
    export {};
}

declare module 'unnamed-network/misc/events' {
    import { CustomEvent } from 'unnamed-network/misc/event-target';
    import { Message } from 'unnamed-network/message/message';
    import { MessageReceivedEvent } from 'unnamed-network/conn/base';
    export class NetworkMessageReceivedEvent extends CustomEvent<Message> {
        type: string;
        messageReceivedEvent: MessageReceivedEvent;
        exactForMe: boolean;
        constructor(messageReceivedEvent: MessageReceivedEvent, exactForMe: boolean);
    }
}

declare module 'unnamed-network/misc/identity' {
    namespace Identity {
        interface Config {
            myAddr?: string;
            signingKeyPair?: CryptoKeyPair;
            encryptionKeyPair?: CryptoKeyPair;
            [opt: string]: any;
        }
        interface Signature {
            random: string;
            sign: string;
        }
    }
    class Identity {
        addr: string;
        exportedSigningPubKey: string;
        expoertedEncryptionPubKey: string;
        constructor(config?: Partial<Identity.Config>);
        generateIfNeeded(): Promise<void>;
        signature(): Promise<Identity.Signature>;
    }
    export default Identity;
    export class PeerIdentity {
        addr: string;
        constructor(peerPath: string, peerSigningPubKeyBase64?: string, peerEncryptionPubKeyBase64?: string);
        setSigningPubKey(peerSigningPubKeyBase64: string): void;
        setEncryptionPubKey(peerEncryptionPubKeyBase64: string): void;
        verify(signature: Identity.Signature): Promise<boolean>;
        verifyUnnamedAddr(): Promise<boolean>;
        verifySignature(signature: Identity.Signature): Promise<boolean>;
    }
}

declare module 'unnamed-network/tunnel' {
    import Agent from 'unnamed-network/agent';
    import EventTarget, { CustomEvent } from 'unnamed-network/misc/event-target';
    import Conn, { MessageReceivedEvent } from 'unnamed-network/conn/base';
    import { Message as OriMessage } from 'unnamed-network/message/message';
    namespace Tunnel {
        type MessageData = Omit<OriMessage, 'srcPath' | 'desPath'> & {
            [_: string]: any;
        };
        const enum Direction {
            A = "A",
            B = "B"
        }
        interface Message extends OriMessage {
            tunnelConnId: string;
            direction: Direction;
        }
        interface StartLinkOpts {
            peerPath: string;
            myPath: string;
            send: (message: Tunnel.Message) => void;
            close: () => void;
        }
        type tunnelConnId = string;
        type ConnIdToThroughs = Record<tunnelConnId, Record<string, [path: string, peerAddr: string]>>;
    }
    interface NewTunnelEventDetail {
        tunnel: TunnelConn;
    }
    class NewTunnelEvent extends CustomEvent<NewTunnelEventDetail> {
        type: string;
    }
    interface EventMap {
        'new-tunnel': NewTunnelEvent;
    }
    class TunnelManager extends EventTarget<EventMap> {
        constructor(agent: Agent);
        onReceiveMessage(event: MessageReceivedEvent): boolean;
        create(peerPath: string, tunnelConnId?: string): Promise<TunnelConn>;
        cacheReceive(fromPeerAddr: string, srcAddr: string, message: OriMessage): void;
        route(message: OriMessage): string | null;
    }
    export default TunnelManager;
    class TunnelConn extends Conn {
        constructor(tunnelConnId?: string);
        startLink(opts: Tunnel.StartLinkOpts): Promise<void>;
        onReceive(event: MessageReceivedEvent): void;
        send(messageContent: Tunnel.MessageData): void;
        close(): Promise<void>;
    }
    export { TunnelConn, NewTunnelEvent };
}

declare module 'unnamed-network/request' {
    import Agent from 'unnamed-network/agent';
    import EventTarget from 'unnamed-network/misc/event-target';
    import { Message as OriMessage, MessageData as OriMessageData } from 'unnamed-network/message/message';
    import { NetworkMessageReceivedEvent } from 'unnamed-network/misc/events';
    namespace Request {
        const enum Direction {
            Request = "request",
            Response = "response"
        }
        interface MessageFields {
            requestId: string;
            direction: Direction;
        }
        interface ResponseMessageData extends OriMessageData {
            responseSpace?: string;
        }
        type Message = OriMessage & MessageFields;
        type RequestMessageData = OriMessageData & MessageFields;
        interface ManagerConfig {
            timeout: number;
        }
        type ResolveFn = (message: Request.Message) => {};
        type requestId = string;
        type RequestIdToThroughs = Record<requestId, [path: string, peerAddr: string]>;
    }
    export class RequestedEvent extends NetworkMessageReceivedEvent {
        type: string;
        responseData?: Promise<Request.ResponseMessageData>;
        response(message: Request.ResponseMessageData | Promise<Request.ResponseMessageData>): void;
    }
    interface EventMap {
        'requested': RequestedEvent;
    }
    class RequestManager extends EventTarget<EventMap> {
        constructor(agent: Agent, config?: Partial<Request.ManagerConfig>);
        onReceiveNetworkMessage(event: NetworkMessageReceivedEvent): boolean;
        request(desPath: string, messageContent: OriMessageData): Promise<Request>;
        cacheReceive(fromPeerAddr: string, srcAddr: string, message: OriMessage): void;
        route(message: OriMessage): string | null;
    }
    export default RequestManager;
    class Request {
        desPath: string;
        requestId: string;
        requestMessage: Request.RequestMessageData;
        responseMessage: Request.Message;
        constructor(desPath: string, messageContent: OriMessageData, requestId?: string);
        start(timeout: number): Promise<Request>;
        complete(message: Request.Message): void;
    }
    export { Request };
}

